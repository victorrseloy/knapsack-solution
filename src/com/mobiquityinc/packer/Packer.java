package com.mobiquityinc.packer;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import com.mobiquityinc.exception.APIException;

public class Packer {
	private static final String LINE_BREAK = "\n";
	
	/**
	 * 
	 * @param filePath
	 * @return
	 */
	public static String pack(String filePath) {
		
		try (Stream<String> stream = Files.lines(Paths.get(filePath))) {
			//for each line we construct a PackerInstance and send it to a solvePackerInstance
			//then we collect all as strings delimited by line breaks
			return stream.map(line -> solvePackerInstance(new PackerInstance(line)))
					.collect(Collectors.joining(LINE_BREAK));

		} catch (IOException e) {
			throw new APIException("Please check your file");
			
		}
	}
	
	
	/**
	 * 
	 * Basically this is a dynamic programming approac to solve the knapsack problem. This solutions have a 
	 * time complexity of O(M*N) and space complexity of O(M*N) where M -> possible items and N bag capacity in decigrams 
	 * 
	 * @param packer a packer instance containing the bag limit in grams and a list of possible items
	 * @return a string containing the list of items included in the solution
	 */
	public static String solvePackerInstance(PackerInstance packer) {
		int itemsListSize = packer.getItems().size();
		//this solutionMatix will be used to store temporary states of my solution
		//the heart of the solution lies here as I am using a dynamic programming approach
		double[][] solutionMatix = new double[itemsListSize+1][packer.getBagLimit()+1];
		
		//this loop makes to solution time complexity be O(M*N) which is the optimal general
		//solution to the knapsack problem
		//I skip the first line and row because they represent the case on which I do not include the item
		for(int itemIndex = 1;itemIndex<=itemsListSize;itemIndex++) {
			for(int weight = 1;weight<=packer.getBagLimit();weight++) {
				PackItem item = packer.getItems().get(itemIndex-1);
				//if my item fits in the current slot I will take it, otherwise I will
				//just copy the left value that represents the best solution found until now
				if(item.getWeight()<=weight) {
					//I need to check what maximize my value
					//1 - include the current item + the best solution for the remaining capacity
					//this is why I have this [weight-item.getWeight()]
					double valueIfAddCurrentItem = item.getValue()+solutionMatix[itemIndex-1][weight-item.getWeight()];
					//or simply copy the best solution found until now(the one that is above my cell) for the previous items
					double valueIfDontAddCurrentItem = solutionMatix[itemIndex-1][weight];
					solutionMatix[itemIndex][weight] = Math.max(valueIfAddCurrentItem, valueIfDontAddCurrentItem);
					
				}
				else {
					//if the item does not fit on my bag, I just copy the previous best 
					//solution found (the one that is above my cell)
					solutionMatix[itemIndex][weight]=solutionMatix[itemIndex-1][weight];
				}
			}
		}
		
		//now that I found the solution I need to run through the generated matrix to check the included items
        return findItemsIncludedInSolution(packer, solutionMatix);
		
	}

	/**
	 * 
	 * This function loops through the products to find the ones included in the result as the time complexity
	 * of this function is O(N) where N is the quantity of possible items to be included in the bag and O(N) < O(M*N) âˆ€ N > 0
	 * this function will not increase the time complexity
	 * 
	 * @param packer - the current packer instance
	 * @param solutionMatix the solution matrix generated by the dynamic programming solution
	 * @return a string containing the list of items included in the solution
	 */
	private static String findItemsIncludedInSolution(PackerInstance packer, double[][] solutionMatix) {
		List<Integer> includedItems = new ArrayList<>();

		int remainingCapacity = packer.getBagLimit();
		//I will iterate over all the items(represented by the matrix line)
		for(int currentItemIndex  = packer.getItems().size()-1;currentItemIndex>0;currentItemIndex-- ) {
			//I will check if my value is different from the value above the current cell
			//if the values does not match this means that the item above my cell is part of the result
			if (solutionMatix[currentItemIndex][remainingCapacity] != 
					solutionMatix[currentItemIndex - 1][remainingCapacity]) {
				//as the items are pre-sorted in a way to match this constraint
				//"You would prefer to send a package which weights less in case there is more than one package with the
				//same price. "
				//I need to check which items is on that addres as the ids and the positions will not necessarely match
				//after the sorting
				includedItems.add(packer.getItems().get(currentItemIndex - 1).getId());
				//as I included this item in the response I need to jump to the solution 
				//before this item inclusion, or the state (s-1)
				remainingCapacity -= packer.getItems().get(currentItemIndex - 1).getWeight();
			}
		}
		
		Collections.sort(includedItems);
		
		if(includedItems.size()>0) {
			//A quick way to include the commas between the items
			return includedItems.stream()
                    .map(item -> item.toString())
                    .collect(Collectors.joining(","));
			
		}
		
		return "-";
	}
}
